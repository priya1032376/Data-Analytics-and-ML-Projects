/* interpretation is in sp 10 slide 3

2.9 - product code wise no of orders.alter
2.10 - revenuwe = total sales (order no wise total sales)

2.11 - profit = msrp-rp (some rs) then sort 

2.4 = popular :  prodcut and order table. count of products... may be self join

2.16 - trigger after insert.

SUMMARY 

Heading : Overall interpretation of sprint 9 and 10 and over 


/*Task 1: Employee Data Analysis

1.1 Find the total number of employees.
1.2 List all employees with their basic information.
1.3 Count the number of employees holding each job title.
1.4 Find the employees who don't have a manager (reportsTo is NULL).
1.5 Calculate total sales generated by each sales representative.
1.6 Find the most profitable sales representative based on total sales.
1.7 Find the names of all employees who have sold more than the average sales amount for their office.

*/

-- Task 1.1 Find the total number of employees.

select * from employees;
select * from offices;

select count(*) as 'Total count of emp' from employees;

-- Task 1.2  List all employees with their basic information.

select employeeNumber, concat(firstName,' ',LastName) as 'Full Name', email, officeCode, JobTitle, reportsTo as 'Reports to' from employees;

-- Task 1.3 Count the number of employees holding each job title.

Select count(employeeNumber), jobtitle from employees group by jobtitle;

-- 1.4 Find the employees who don't have a manager (reportsTo is NULL).

select concat(firstName,' ',LastName) as 'EMP not Reports to anyone', reportsTo from employees
where reportsto is Null;

-- Task 1.5 Calculate total sales generated by each sales representative

select * from customers;
select * from orders;
select * from orderdetails;

select sum(od.quantityOrdered*priceEach) as 'Total Sales', c.salesRepEmployeeNumber from orderdetails od
inner join orders o on od.orderNumber=o.orderNumber
inner join customers c on c.customerNumber=o.customerNumber
group by c.salesRepEmployeeNumber order by sum(od.quantityOrdered*priceEach) desc;


-- Task 1.6 Find the most profitable sales representative based on total sales.

select sum(od.quantityOrdered*priceEach) as 'Total Sales', c.salesRepEmployeeNumber from orderdetails od
inner join orders o on od.orderNumber=o.orderNumber
inner join customers c on c.customerNumber=o.customerNumber
group by c.salesRepEmployeeNumber order by sum(od.quantityOrdered*priceEach) desc Limit 1;

-- Task 1.7 Find the names of all employees who have sold more than the average sales amount for their office.

select e.employeeNumber, concat(e.firstname,' ',e.lastName) as 'Emp Name', sum(od.quantityOrdered*priceEach) as 'Total Sales', avg(od.quantityOrdered*priceEach) as 'office wise Avg sales', e.officeCode from employees e
inner join customers c on c.salesRepEmployeeNumber=e.employeeNumber
inner join orders o on o.customerNumber=c.customerNumber
inner join orderdetails od on od.ordernumber=o.orderNumber
group by e.officecode, e.employeeNumber
having sum(od.quantityOrdered*priceEach) > (  
select avg(emp_sales.totalsale) from (
select sum(odd.quantityOrdered*priceEach) as totalsale, ee.officeCode from employees ee
inner join customers cc on cc.salesRepEmployeeNumber=ee.employeeNumber
inner join orders oo on oo.customerNumber=cc.customerNumber
inner join orderdetails odd on odd.ordernumber=oo.orderNumber
group by ee.officecode, ee.employeeNumber
) as emp_sales where emp_sales.officecode=e.officecode)
 order by 'Total Sales' Desc;

/*
Task 2: Order Analysis

2.1 Find the average order amount for each customer.
2.2 Find the number of orders placed in each month.
2.3 Identify orders that are still pending shipment (status = 'Pending').
2.4 List orders along with customer details.
2.5 Retrieve the most recent orders (based on order date).
2.6 Calculate total sales for each order.
2.7 Find the highest-value order based on total sales.
2.8 List all orders with their corresponding order details.
2.9 List the most frequently ordered products.
2.10 Calculate total revenue for each order.
2.11 Identify the most profitable orders based on total revenue.
2.12 List all orders with detailed product information.
2.13 Identify orders with delayed shipping (shippedDate > requiredDate).
2.14 Find the most popular product combinations within orders.
2.15 Calculate revenue for each order and identify the top 10 most profitable.
2.16 Create a trigger that automatically updates a customer's credit limit after a new order is placed, reducing it by the order total.
2.17 Create a trigger that logs product quantity changes whenever an order detail is inserted or updated.

*/

-- Task 2.1 Find the average order amount for each customer.

select * from products;
select * from orderdetails;
select * from orders;
select * from customers;
select * from payments;

select avg(amount) as 'Average order amount', customerNumber from payments group by customerNumber order by avg(amount) desc;

-- Task 2.2 Find the number of orders placed in each month.

select count(orderNumber) as 'No. of orders', month(orderdate) as 'Month Number', monthname(orderdate) as 'Order Month' from orders
group by month(orderdate), monthname(orderdate) order by month(orderdate) asc;

-- Task 2.3 Identify orders that are still pending shipment (status = 'Pending') / (no pending checking for - cancelled as well).

select OrderNumber, status from orders where lower(status) Like 'pending' or lower(status) Like 'cancelled';

-- Task 2.4 List orders along with customer details.

select * from customers;
select * from orders;
select * from orderdetails;

select o.orderNumber, c.customerName, c.customerName,c.phone,c.country,c.creditLimit from customers c 
inner join orders o on c.customerNumber=o.customerNumber
group by o.orderNumber;

-- task 2.5 Retrieve the most recent orders (based on order date).

select * from orders order by orderdate desc limit 1;


-- Task 2.6 Calculate total sales for each order.
select sum(od.quantityOrdered*od.priceEach) as 'Total Sales', o.orderNumber from orderdetails od
inner join orders o on od.orderNumber=o.orderNumber
group by o.orderNumber;

-- Task 2.7 Find the highest-value order based on total sales.
select sum(od.quantityOrdered*od.priceEach) as 'Maximum Sales', o.orderNumber from orderdetails od
inner join orders o on od.orderNumber=o.orderNumber
group by o.orderNumber order by sum(od.quantityOrdered*od.priceEach) desc limit 1;

-- Task 2.8 List all orders with their corresponding order details.

SELECT o.orderNumber, o.orderDate, o.status, od.productCode, od.quantityOrdered, od.priceEach, od.orderLineNumber
FROM orders o
JOIN orderdetails od ON o.orderNumber = od.orderNumber
ORDER BY o.orderNumber;

-- Task 2.9 List the most frequently ordered products.

select productcode, count(orderNumber) from orderdetails group by productcode order by count(orderNumber) desc Limit 1;

-- Task 2.10 Calculate total revenue for each order.

select * from orders;
select * from orderdetails;
select * from products;

SELECT o.orderNumber, SUM(od.quantityOrdered * od.priceEach) AS totalRevenue FROM orders o
INNER JOIN orderdetails od ON o.orderNumber = od.orderNumber
GROUP BY o.orderNumber;

-- Task 2.11 Identify the most profitable orders based on total revenue.

SELECT o.orderNumber, SUM(od.quantityOrdered * od.priceEach) AS totalRevenue FROM orders o
INNER JOIN orderdetails od ON o.orderNumber = od.orderNumber
GROUP BY o.orderNumber
ORDER BY totalRevenue DESC LIMIT 1; 

-- Task 2.12 List all orders with detailed product information.

SELECT o.orderNumber, o.orderDate, o.status, od.productCode, p.productName, p.productLine, p.productScale, p.productVendor, 
p.productDescription, od.quantityOrdered, od.priceEach, (od.quantityOrdered * od.priceEach) AS totalPrice
FROM orders o
INNER JOIN orderdetails od ON o.orderNumber = od.orderNumber
INNER JOIN products p ON od.productCode = p.productCode
ORDER BY o.orderNumber;


-- Task 2.13 Identify orders with delayed shipping (shippedDate > requiredDate).

SELECT orderNumber, orderDate, requiredDate, shippedDate, status
FROM orders
WHERE shippedDate > requiredDate;

-- Task 2.14 Find the most popular product combinations within orders.

SELECT od1.productCode AS productCode1, od2.productCode AS productCode2, COUNT(*) AS combinationCount
FROM orderdetails od1
INNER JOIN orderdetails od2 ON od1.orderNumber = od2.orderNumber AND od1.productCode < od2.productCode
GROUP BY od1.productCode, od2.productCode
ORDER BY combinationCount DESC;

-- Task 2.15 Calculate revenue for each order and identify the top 10 most profitable.

SELECT o.orderNumber, SUM(od.quantityOrdered * od.priceEach) AS totalRevenue
FROM orders o
INNER JOIN orderdetails od ON o.orderNumber = od.orderNumber
GROUP BY o.orderNumber
ORDER BY totalRevenue DESC
LIMIT 10; 

-- Task 2.16 Create a trigger that automatically updates a customer's credit limit after a new order is placed, 
-- reducing it by the order total.

DELIMITER $$
CREATE TRIGGER update_credit_limit_after_order AFTER INSERT ON orders FOR EACH ROW
BEGIN
    DECLARE orderTotal DECIMAL(10, 2);
    SELECT SUM(od.quantityOrdered * od.priceEach) 
    INTO orderTotal
    FROM orderdetails od
    WHERE od.orderNumber = NEW.orderNumber;

    -- Updating the customer's credit limit
    UPDATE customers
    SET creditLimit = creditLimit - orderTotal
    WHERE customerNumber = NEW.customerNumber;
END$$

select * from customers;
select * from orderdetails;
select * from orders;

insert into orderdetails(orderNumber, productcode, quantityordered, priceEach, orderlineNumber)
values(10100,'S18_1749',10,100.00,3);

insert into orders(orderNumber, orderdate, requireddate, shippeddate, status, comments, customerNumber)
values(10100, '2024-01-06', '2024-02,10', '2024-02,07','Shipped',Null, 363);

select Order



-- Task 2.17 Create a trigger that logs product quantity changes whenever an order detail is inserted or updated.

-- creating a log table :

CREATE TABLE product_quantity_log (
    logID INT AUTO_INCREMENT PRIMARY KEY,
    productCode VARCHAR(15),
    orderNumber INT,
    oldQuantity INT,
    newQuantity INT,
    changeType VARCHAR(10),
    changeDate TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


-- Insert Trigger
DELIMITER $$
CREATE TRIGGER log_product_quantity_insert AFTER INSERT ON orderdetails FOR EACH ROW
BEGIN
    INSERT INTO product_quantity_log (productCode, orderNumber, oldQuantity, newQuantity, changeType)
    VALUES (NEW.productCode, NEW.orderNumber, NULL, NEW.quantityOrdered, 'INSERT');
END$$


DELIMITER $$
CREATE TRIGGER log_product_quantity_update AFTER UPDATE ON orderdetails FOR EACH ROW
BEGIN
    INSERT INTO product_quantity_log (productCode, orderNumber, oldQuantity, newQuantity, changeType)
    VALUES (NEW.productCode, NEW.orderNumber, OLD.quantityOrdered, NEW.quantityOrdered, 'UPDATE');
END$$
